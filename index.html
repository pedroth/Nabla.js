<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>∇.js playground</title>
    <link rel="stylesheet" href="./index.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
</head>

<body>
    <div id="root">
        <!-- Elements to be injected here -->
    </div>
</body>
<script type="module">
    import hljs from "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/es/highlight.min.js"
    const isGithub = window.location.host === "pedroth.github.io";
    const SOURCE = isGithub ? "/nabla.js" : "";


    const { DOM, useState, debounce, svg, codeEval, NablaStorage } = await import(SOURCE + "/io/index.js")

    //========================================================================================
    /*                                                                                      *
     *                                         UTILS                                        *
     *                                                                                      */
    //========================================================================================

    function saveToLocalStorage() {
        NablaStorage.setItem("AppState", AppState.cells.map(x => x.serialize()))
    }

    function highlightCode(code) {
        return hljs.highlight(
            code,
            { language: "javascript" }
        ).value;
    }

    // ChatGPT
    function saveCursorPosition(editableDiv) {
        let cursorOffset = 0;
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(editableDiv);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            cursorOffset = preCaretRange.toString().length; // Save the character offset
        }
        return cursorOffset;
    }

    // ChatGPT with some changes
    function restoreCursorPosition(cursorOffset, editableDiv) {
        const selection = window.getSelection();
        const range = document.createRange();
        let currentOffset = 0;

        function traverseNodes(node) {
            if (node.nodeType === Node.TEXT_NODE) {
                const nodeLength = node.textContent.length;
                if (currentOffset + nodeLength >= cursorOffset) {
                    range.setStart(node, cursorOffset - currentOffset);
                    range.setEnd(node, cursorOffset - currentOffset);
                    selection.removeAllRanges();
                    selection.addRange(range);
                    return true;
                } else {
                    currentOffset += nodeLength;
                }
            } else {
                for (let i = 0; i < node.childNodes.length; i++) {
                    if (traverseNodes(node.childNodes[i])) {
                        return true;
                    }
                }
            }
            return false;
        }
        traverseNodes(editableDiv);
    }


    //========================================================================================
    /*                                                                                      *
     *                                          UI                                          *
     *                                                                                      */
    //========================================================================================

    function delCell(cell) {
        const { getCellState, setCellState } = cell;
        const { id, input } = getCellState();
        AppState.cellsContainer.element.removeChild(document.getElementById(id));
        AppState.cells = AppState.cells.filter(p => p.id !== id)
        console.log(`${AppState.cellsContainer}`);
    }

    function evalCell(cell) {
        const { getCellState, setCellState } = cell;
        const { id, input } = getCellState()
        const result = codeEval(input);
        setCellState(() => ({ output: result.toString() }));
    }

    function cellInput(cell) {
        const { getCellState, setCellState, onCellStateChange } = cell;
        const { input } = getCellState();
        const codeDOM = DOM.of("code")
            .addClass("grow")
            .style(`
                         width: auto;
                         height: auto; 
                         border:solid; 
                         border-radius: 5px;
                         min-height: 5rem
                         `)
            .attr("contenteditable", true)
            .inner(highlightCode(input))
            .event("input",
                debounce(
                    e => {
                        setCellState(() => ({ input: e.target.textContent }))
                        saveToLocalStorage();
                    }
                )
            )
            .event("keydown", (e) => {
                if (e.key === 'Enter' && e.shiftKey) {
                    e.preventDefault();
                    evalCell(cell);
                    saveToLocalStorage();
                }
            });

        onCellStateChange(({ input }) => {
            const hlCode = highlightCode(input);
            codeDOM.map(raw => {
                const cursorOffset = saveCursorPosition(raw);
                codeDOM.inner(hlCode);
                restoreCursorPosition(cursorOffset, raw);
            })
        })
        const inputDOM = DOM.of("pre")
            .addClass("flex")
            .appendChild(
                codeDOM
            )
        return inputDOM;
    }

    function cellOutput(cell) {
        const { onCellStateChange, getCellState } = cell;
        const { output } = getCellState(); // initial state
        const outputDOM = DOM.of("pre").style("overflow-x: auto").inner(output);
        onCellStateChange(({ output }) => {
            outputDOM.inner(output);
        })
        return outputDOM;
    }

    function delBtn(cell) {
        return DOM.of("button")
            .attr("title", "delete cell (shift+enter)")
            .addClass("iconBtn")
            .style(`margin-left: auto; color:var(--secondary-color)`)
            .inner(svg(`${SOURCE}/assets/garbage.svg`))
            .event("click", () => delCell(cell));
    }

    function runBtn(cell) {
        const { getCellState, setCellState } = cell;
        return DOM.of("button")
            .attr("title", "run cell (shift+enter)")
            .addClass("iconBtn")
            .style(`margin-left: auto;`)
            .inner(svg(`${SOURCE}/assets/play.svg`))
            .event("click", () => evalCell(cell));
    }

    function renderCell(cell) {
        const ans = DOM.of("div")
            .attr("id", cell.id)
            .addClass("flex column grow")
            .appendChild(
                cellOutput(cell),
                cellInput(cell),
                DOM.of("div")
                    .style("margin-left: auto")
                    .appendChild(
                        delBtn(cell),
                        runBtn(cell)
                    )
            );
        
        return ans;
    }

    function renderCells() {
        const cells = AppState.cells;
        return cells.map(cell => renderCell(cell));
    }

    function addCellBtn(cellsContainer) {
        const addCellAction = () => {
            const { cells } = AppState;
            const newCell = cell(crypto.randomUUID());
            cells.push(newCell);
            cellsContainer.appendChild(renderCell(newCell));
        }
        window.addEventListener("keydown", (e) => {
            if (e.key === 'Enter' && e.ctrlKey) {
                e.preventDefault();
                addCellAction();
            }
        })
        return DOM.of("button")
            .attr("title", "add new cell (ctrl+enter)")
            .addClass("iconBtn")
            .event("click", () => addCellAction())
            .inner(svg(`${SOURCE}/assets/plus.svg`))
    }

    function main() {
        const container = DOM.of("main");
        const cellsContainer = DOM.of("div")
            .addClass("flex spaced-items column")
            .appendChild(...renderCells());
        AppState.cellsContainer = cellsContainer;
        return container
            .appendChild(
                cellsContainer,
                addCellBtn(cellsContainer)
            )
    }

    function footer() {
        return DOM.of("footer")
            .appendChild(
                DOM.of("hr"),
                DOM.of("p")
                    .addClass("center")
                    .inner(`© ${new Date().getFullYear()} Pedroth`)
            )
    }

    function header() {
        return DOM.of("header")
            .appendChild(
                DOM.of("h1").appendChild(
                    DOM.of("a")
                        .attr("href", "https://github.com/pedroth/nabla.js")
                        .attr("target", "_blank")
                        .inner("∇ nabla.js")
                ),
                DOM.of("hr")
            )
    }

    function renderUI() {
        return DOM.ofId("root")
            .map(root =>
                root.appendChild(header())
                    .appendChild(main())
                    .appendChild(footer())
                    .addClass("loaded")
            )
            .orElse(() => DOM.of("div"));
    }

    function deserializeCell(json) {
        const { id, input, output } = json;
        const c = cell(id);
        c.setCellState(() => ({ input, output }));
        return c;
    }

    function cell(id) {
        const [getCellState, setCellState, onCellStateChange] = useState({ id, input: "", output: "" })
        const ans = {
            id,
            getCellState,
            setCellState,
            onCellStateChange,
            serialize: () => {
                const { id, input, output } = getCellState();
                return { id, input, output };
            }
        };
        return ans;
    }

    //========================================================================================
    /*                                                                                      *
     *                                         MAIN                                         *
     *                                                                                      */
    //========================================================================================


    function getInitialCells() {
        const cells = (NablaStorage.getItem("AppState") ?? []).map(x => deserializeCell(x));
        const defaultCell = cell(crypto.randomUUID());
        defaultCell.setCellState(() => ({ input: `Maybe.of("Type some nabla.js code").orElse();` }))
        return cells.length === 0 ? [defaultCell] : cells;
    }

    const AppState = { cells: getInitialCells(), cellsContainer: undefined }
    renderUI();
</script>

</html>